<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Lecture 18: Modeling team ratings and posterior predictions – Special Topics: Sports Analytics 36-460/660</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-51f09ead35d5b96974be4249e4526bd0.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar docked">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item">
      Special Topics: Sports Analytics 36-460/660
      </li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
    <div class="pt-lg-2 mt-2 text-center sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">Special Topics: Sports Analytics 36-460/660</a> 
        <div class="sidebar-tools-main">
    <a href="https://github.com/ryurko/cmu-sportsanalytics-spring25" title="GitHub" class="quarto-navigation-tool px-1" aria-label="GitHub"><i class="bi bi-github"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Home</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Lectures</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../demos.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Demos</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#poisson-multilevel-model" id="toc-poisson-multilevel-model" class="nav-link" data-scroll-target="#poisson-multilevel-model">Poisson multilevel model</a></li>
  <li><a href="#bayesian-hierarchical-poisson-model" id="toc-bayesian-hierarchical-poisson-model" class="nav-link" data-scroll-target="#bayesian-hierarchical-poisson-model">Bayesian hierarchical Poisson model</a></li>
  <li><a href="#generating-posterior-predictions" id="toc-generating-posterior-predictions" class="nav-link" data-scroll-target="#generating-posterior-predictions">Generating posterior predictions</a></li>
  <li><a href="#posterior-predictive-check" id="toc-posterior-predictive-check" class="nav-link" data-scroll-target="#posterior-predictive-check">Posterior predictive check</a></li>
  <li><a href="#prior-predictive-check" id="toc-prior-predictive-check" class="nav-link" data-scroll-target="#prior-predictive-check">Prior predictive check</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lecture 18: Modeling team ratings and posterior predictions</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>The purpose of this demo is introduce basic approaches for modeling team ratings based on the soccer match data from HW1. As a reminder, this dataset in the homeworks/hw1 folder on Canvas (<code>soccer_match_goals.csv</code>) and contains the goals scored across men’s soccer matches in the five biggest European leagues during the 2023-2024 season. This dataset contains the following columns:</p>
<ol type="1">
<li><p><code>goals</code>: number of goals scored by <code>team</code> in a match</p></li>
<li><p><code>xG</code>: accumulated number of expected goals by <code>team</code> in a match</p></li>
<li><p><code>off_team</code>: the team name affiliated with the <strong>offense scoring</strong> the number of <code>goals</code> and total <code>xG</code></p></li>
<li><p><code>def_team</code>: the team name affiliated with the <strong>defense allowing</strong> the number of <code>goals</code> and total <code>xG</code></p></li>
<li><p><code>league</code>: string denoting the country: ENG (Premier League), ESP (La Liga), FRA (Ligue 1), GER (Fußball-Bundesliga), and ITA (Serie A)</p></li>
<li><p><code>match_id</code>: unique identifier for each match, such that each match has two rows in the dataset, one for the home team and one for the away team</p></li>
<li><p><code>is_home</code>: binary indicator denoting whether or not the team was the home team in the match.</p></li>
</ol>
<p>Note that each row in this dataset corresponds to information about a team’s offensive performance for a single match. This means a team is repeatedly observed for each match they played during the 2023-2024 season. I constructed this dataset using the <a href="https://jaseziv.github.io/worldfootballR/">worldfootballR</a> package, and the script <code>init_soccer_match_goals.R</code> on Canvas is the code I used to make the dataset.</p>
<p>The code chunk below loads in the data, and then for ease we’ll only consider matches in the Premier League (i.e., <code>league == ENG</code>).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>match_goals_scored <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(here<span class="sc">::</span><span class="fu">here</span>(<span class="st">"data/soccer_match_goals.csv"</span>))</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the ENG only table:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>eng_match_goals_scored <span class="ot">&lt;-</span> match_goals_scored <span class="sc">|&gt;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(league <span class="sc">==</span> <span class="st">"ENG"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>eng_match_goals_scored</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 760 × 7
   goals    xG off_team       def_team        league match_id is_home
   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;           &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;
 1     0   0.3 Burnley        Manchester City ENG           1       1
 2     2   0.8 Arsenal        Nott'ham Forest ENG           2       1
 3     0   2.7 Everton        Fulham          ENG           3       1
 4     0   0.5 Sheffield Utd  Crystal Palace  ENG           4       1
 5     4   4   Brighton       Luton Town      ENG           5       1
 6     1   1.3 Bournemouth    West Ham        ENG           6       1
 7     5   3.3 Newcastle Utd  Aston Villa     ENG           7       1
 8     2   2.2 Brentford      Tottenham       ENG           8       1
 9     1   1.4 Chelsea        Liverpool       ENG           9       1
10     1   2.2 Manchester Utd Wolves          ENG          10       1
# ℹ 750 more rows</code></pre>
</div>
</div>
</section>
<section id="poisson-multilevel-model" class="level2">
<h2 class="anchored" data-anchor-id="poisson-multilevel-model">Poisson multilevel model</h2>
<p>As discussed in lecture, we’ll start with the traditional <code>lme4</code> multilevel model that we’ve discussed earlier in the semester:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(lme4)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>glmer_goal_model <span class="ot">&lt;-</span> <span class="fu">glmer</span>(goals <span class="sc">~</span> is_home <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> off_team) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> def_team),</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">family =</span> poisson,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                               <span class="at">data =</span> eng_match_goals_scored)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(glmer_goal_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Generalized linear mixed model fit by maximum likelihood (Laplace
  Approximation) [glmerMod]
 Family: poisson  ( log )
Formula: goals ~ is_home + (1 | off_team) + (1 | def_team)
   Data: eng_match_goals_scored

     AIC      BIC   logLik deviance df.resid 
  2376.2   2394.8  -1184.1   2368.2      756 

Scaled residuals: 
    Min      1Q  Median      3Q     Max 
-1.6616 -0.6872 -0.1526  0.5728  3.1149 

Random effects:
 Groups   Name        Variance Std.Dev.
 off_team (Intercept) 0.05783  0.2405  
 def_team (Intercept) 0.05268  0.2295  
Number of obs: 760, groups:  off_team, 20; def_team, 20

Fixed effects:
            Estimate Std. Error z value Pr(&gt;|z|)    
(Intercept)  0.33650    0.08597   3.914 9.06e-05 ***
is_home      0.19645    0.05664   3.469 0.000523 ***
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Correlation of Fixed Effects:
        (Intr)
is_home -0.362</code></pre>
</div>
</div>
<p>We could proceed to use this model in the format we discussed earlier in the semester… however that fails to propagate the uncertainty we have about the parameters. Instead we can fit the fully Bayesian version of this model with relative ease.</p>
</section>
<section id="bayesian-hierarchical-poisson-model" class="level2">
<h2 class="anchored" data-anchor-id="bayesian-hierarchical-poisson-model">Bayesian hierarchical Poisson model</h2>
<p>Rather than using <code>lme4</code> to fit the frequentist version of the multilevel model, we can use the exact same type of syntax with the <a href="https://mc-stan.org/rstanarm/"><code>rstanarm</code> package</a> to fit the fully Bayesian version of the model. Behind the scenes, this calls Stan and uses <strong>pre-compiled</strong> model code to perform the posterior sampling. If we do not have any informative prior knowledge, then we can be relatively lazy easy in terms of using the default priors that are autoscaled based on the variance in the data - resulting in weakly informative priors that apply shrinkage to parameter estimates. The code chunk below fits the Bayesian model with <code>stan_glmer()</code> which is simply the Bayesian version of the <code>glmer()</code> function from above <strong>with the exact same syntax</strong>:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(rstanarm)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'rstanarm' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: Rcpp</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: package 'Rcpp' was built under R version 4.2.3</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>This is rstanarm version 2.32.1</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>- See https://mc-stan.org/rstanarm/articles/priors for changes to default priors!</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>- Default priors may change, so it's safest to specify priors, even if equivalent to the defaults.</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>- For execution on a local, multicore CPU with excess RAM we recommend calling</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>  options(mc.cores = parallel::detectCores())</code></pre>
</div>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>team_goals_model <span class="ot">&lt;-</span> <span class="fu">stan_glmer</span>(goals <span class="sc">~</span> is_home <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> off_team) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> def_team),</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>                               <span class="at">family =</span> poisson,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>                               <span class="at">data =</span> eng_match_goals_scored, <span class="at">seed =</span> <span class="dv">2013</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
SAMPLING FOR MODEL 'count' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 0.000255 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 2.55 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 1.453 seconds (Warm-up)
Chain 1:                0.726 seconds (Sampling)
Chain 1:                2.179 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 4.1e-05 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.41 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 1.415 seconds (Warm-up)
Chain 2:                0.735 seconds (Sampling)
Chain 2:                2.15 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 4.2e-05 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.42 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 1.28 seconds (Warm-up)
Chain 3:                0.642 seconds (Sampling)
Chain 3:                1.922 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 3.9e-05 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.39 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 1.778 seconds (Warm-up)
Chain 4:                0.789 seconds (Sampling)
Chain 4:                2.567 seconds (Total)
Chain 4: </code></pre>
</div>
</div>
<p>Notice that this model fits very quickly! We see the same type of output from running Stan code like before, with displays of the run time of the four chains. Notice that the default settings using 2000 iterations in total for each chain, with the first half used for burn-in. We could change the same inputs from before, e.g., <code>chains</code>, <code>iter</code>, and <code>warmup</code>, if we want to make any changes to the number of samples.</p>
<p>What happens when we call the <code>summary()</code> function on this model?</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(team_goals_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Model Info:
 function:     stan_glmer
 family:       poisson [log]
 formula:      goals ~ is_home + (1 | off_team) + (1 | def_team)
 algorithm:    sampling
 sample:       4000 (posterior sample size)
 priors:       see help('prior_summary')
 observations: 760
 groups:       off_team (20), def_team (20)

Estimates:
                                          mean   sd   10%   50%   90%
(Intercept)                              0.3    0.1  0.2   0.3   0.5 
is_home                                  0.2    0.1  0.1   0.2   0.3 
b[(Intercept) off_team:Arsenal]          0.3    0.1  0.2   0.3   0.5 
b[(Intercept) off_team:Aston_Villa]      0.2    0.1  0.0   0.2   0.3 
b[(Intercept) off_team:Bournemouth]     -0.1    0.1 -0.3  -0.1   0.1 
b[(Intercept) off_team:Brentford]       -0.1    0.1 -0.2  -0.1   0.1 
b[(Intercept) off_team:Brighton]        -0.1    0.1 -0.2  -0.1   0.1 
b[(Intercept) off_team:Burnley]         -0.3    0.1 -0.5  -0.3  -0.1 
b[(Intercept) off_team:Chelsea]          0.2    0.1  0.0   0.2   0.4 
b[(Intercept) off_team:Crystal_Palace]  -0.1    0.1 -0.2  -0.1   0.1 
b[(Intercept) off_team:Everton]         -0.3    0.1 -0.5  -0.3  -0.1 
b[(Intercept) off_team:Fulham]          -0.1    0.1 -0.2  -0.1   0.1 
b[(Intercept) off_team:Liverpool]        0.3    0.1  0.1   0.3   0.4 
b[(Intercept) off_team:Luton_Town]      -0.1    0.1 -0.3  -0.1   0.1 
b[(Intercept) off_team:Manchester_City]  0.4    0.1  0.2   0.4   0.5 
b[(Intercept) off_team:Manchester_Utd]  -0.1    0.1 -0.2  -0.1   0.1 
b[(Intercept) off_team:Newcastle_Utd]    0.3    0.1  0.1   0.3   0.4 
b[(Intercept) off_team:Nott'ham_Forest] -0.2    0.1 -0.3  -0.2   0.0 
b[(Intercept) off_team:Sheffield_Utd]   -0.4    0.2 -0.6  -0.4  -0.2 
b[(Intercept) off_team:Tottenham]        0.2    0.1  0.0   0.2   0.3 
b[(Intercept) off_team:West_Ham]         0.0    0.1 -0.2   0.0   0.2 
b[(Intercept) off_team:Wolves]          -0.1    0.1 -0.3  -0.1   0.0 
b[(Intercept) def_team:Arsenal]         -0.5    0.2 -0.7  -0.5  -0.3 
b[(Intercept) def_team:Aston_Villa]      0.0    0.1 -0.2   0.0   0.2 
b[(Intercept) def_team:Bournemouth]      0.1    0.1 -0.1   0.1   0.2 
b[(Intercept) def_team:Brentford]        0.0    0.1 -0.1   0.0   0.2 
b[(Intercept) def_team:Brighton]         0.0    0.1 -0.1   0.0   0.2 
b[(Intercept) def_team:Burnley]          0.2    0.1  0.0   0.2   0.3 
b[(Intercept) def_team:Chelsea]          0.0    0.1 -0.1   0.0   0.2 
b[(Intercept) def_team:Crystal_Palace]   0.0    0.1 -0.2   0.0   0.1 
b[(Intercept) def_team:Everton]         -0.1    0.1 -0.3  -0.1   0.0 
b[(Intercept) def_team:Fulham]           0.0    0.1 -0.2   0.0   0.2 
b[(Intercept) def_team:Liverpool]       -0.3    0.1 -0.5  -0.3  -0.1 
b[(Intercept) def_team:Luton_Town]       0.3    0.1  0.1   0.3   0.4 
b[(Intercept) def_team:Manchester_City] -0.4    0.1 -0.6  -0.4  -0.2 
b[(Intercept) def_team:Manchester_Utd]   0.0    0.1 -0.2   0.0   0.1 
b[(Intercept) def_team:Newcastle_Utd]    0.0    0.1 -0.1   0.0   0.2 
b[(Intercept) def_team:Nott'ham_Forest]  0.1    0.1 -0.1   0.1   0.2 
b[(Intercept) def_team:Sheffield_Utd]    0.4    0.1  0.3   0.4   0.6 
b[(Intercept) def_team:Tottenham]        0.0    0.1 -0.2   0.0   0.2 
b[(Intercept) def_team:West_Ham]         0.2    0.1  0.0   0.1   0.3 
b[(Intercept) def_team:Wolves]           0.0    0.1 -0.1   0.0   0.2 
Sigma[off_team:(Intercept),(Intercept)]  0.1    0.0  0.0   0.1   0.1 
Sigma[def_team:(Intercept),(Intercept)]  0.1    0.0  0.0   0.1   0.1 

Fit Diagnostics:
           mean   sd   10%   50%   90%
mean_PPD 1.6    0.1  1.6   1.6   1.7  

The mean_ppd is the sample average posterior predictive distribution of the outcome variable (for details see help('summary.stanreg')).

MCMC diagnostics
                                        mcse Rhat n_eff
(Intercept)                             0.0  1.0  1021 
is_home                                 0.0  1.0  5257 
b[(Intercept) off_team:Arsenal]         0.0  1.0  2461 
b[(Intercept) off_team:Aston_Villa]     0.0  1.0  2485 
b[(Intercept) off_team:Bournemouth]     0.0  1.0  2699 
b[(Intercept) off_team:Brentford]       0.0  1.0  2892 
b[(Intercept) off_team:Brighton]        0.0  1.0  2850 
b[(Intercept) off_team:Burnley]         0.0  1.0  3235 
b[(Intercept) off_team:Chelsea]         0.0  1.0  2835 
b[(Intercept) off_team:Crystal_Palace]  0.0  1.0  2866 
b[(Intercept) off_team:Everton]         0.0  1.0  3113 
b[(Intercept) off_team:Fulham]          0.0  1.0  2579 
b[(Intercept) off_team:Liverpool]       0.0  1.0  2908 
b[(Intercept) off_team:Luton_Town]      0.0  1.0  2842 
b[(Intercept) off_team:Manchester_City] 0.0  1.0  2805 
b[(Intercept) off_team:Manchester_Utd]  0.0  1.0  2907 
b[(Intercept) off_team:Newcastle_Utd]   0.0  1.0  2255 
b[(Intercept) off_team:Nott'ham_Forest] 0.0  1.0  2915 
b[(Intercept) off_team:Sheffield_Utd]   0.0  1.0  3123 
b[(Intercept) off_team:Tottenham]       0.0  1.0  2321 
b[(Intercept) off_team:West_Ham]        0.0  1.0  2791 
b[(Intercept) off_team:Wolves]          0.0  1.0  2779 
b[(Intercept) def_team:Arsenal]         0.0  1.0  3324 
b[(Intercept) def_team:Aston_Villa]     0.0  1.0  2557 
b[(Intercept) def_team:Bournemouth]     0.0  1.0  2744 
b[(Intercept) def_team:Brentford]       0.0  1.0  2530 
b[(Intercept) def_team:Brighton]        0.0  1.0  2466 
b[(Intercept) def_team:Burnley]         0.0  1.0  2517 
b[(Intercept) def_team:Chelsea]         0.0  1.0  2494 
b[(Intercept) def_team:Crystal_Palace]  0.0  1.0  2900 
b[(Intercept) def_team:Everton]         0.0  1.0  2924 
b[(Intercept) def_team:Fulham]          0.0  1.0  2755 
b[(Intercept) def_team:Liverpool]       0.0  1.0  3181 
b[(Intercept) def_team:Luton_Town]      0.0  1.0  2538 
b[(Intercept) def_team:Manchester_City] 0.0  1.0  3075 
b[(Intercept) def_team:Manchester_Utd]  0.0  1.0  3105 
b[(Intercept) def_team:Newcastle_Utd]   0.0  1.0  2924 
b[(Intercept) def_team:Nott'ham_Forest] 0.0  1.0  2883 
b[(Intercept) def_team:Sheffield_Utd]   0.0  1.0  2489 
b[(Intercept) def_team:Tottenham]       0.0  1.0  2784 
b[(Intercept) def_team:West_Ham]        0.0  1.0  2762 
b[(Intercept) def_team:Wolves]          0.0  1.0  2591 
Sigma[off_team:(Intercept),(Intercept)] 0.0  1.0  1337 
Sigma[def_team:(Intercept),(Intercept)] 0.0  1.0  1087 
mean_PPD                                0.0  1.0  3910 
log-posterior                           0.2  1.0   937 

For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).</code></pre>
</div>
</div>
<p>We can view the traditional type of summary we care about with the <code>print()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(team_goals_model, <span class="at">digits =</span> <span class="dv">4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>stan_glmer
 family:       poisson [log]
 formula:      goals ~ is_home + (1 | off_team) + (1 | def_team)
 observations: 760
------
            Median MAD_SD
(Intercept) 0.3356 0.0882
is_home     0.1963 0.0574

Error terms:
 Groups   Name        Std.Dev.
 off_team (Intercept) 0.26685 
 def_team (Intercept) 0.25594 
Num. levels: off_team 20, def_team 20 

------
* For help interpreting the printed output see ?print.stanreg
* For info on the priors used see ?prior_summary.stanreg</code></pre>
</div>
</div>
<p>You can see that the display here is fairly similar to the output from <code>lme4</code>, with slightly different values. However, the key difference is we have access to posterior samples for all of parameters. We can grab such posterior samples in a similar to the <code>rstan</code> output:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>posterior_sample <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(team_goals_model) <span class="sc">|&gt;</span> <span class="fu">as_tibble</span>()</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>posterior_sample</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 44
   `(Intercept)` is_home b[(Intercept) off_team:Arsenal…¹ b[(Intercept) off_te…²
           &lt;dbl&gt;   &lt;dbl&gt;                            &lt;dbl&gt;                  &lt;dbl&gt;
 1         0.335   0.180                            0.233                 0.207 
 2         0.288   0.287                            0.366                -0.0537
 3         0.226   0.271                            0.359                 0.250 
 4         0.454   0.123                            0.343                 0.173 
 5         0.394   0.164                            0.327                 0.176 
 6         0.469   0.157                            0.185                 0.232 
 7         0.474   0.204                            0.256                 0.274 
 8         0.449   0.225                            0.372                 0.137 
 9         0.468   0.209                            0.246                 0.0665
10         0.531   0.189                            0.294                 0.116 
# ℹ 3,990 more rows
# ℹ abbreviated names: ¹​`b[(Intercept) off_team:Arsenal]`,
#   ²​`b[(Intercept) off_team:Aston_Villa]`
# ℹ 40 more variables: `b[(Intercept) off_team:Bournemouth]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Brentford]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Brighton]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Burnley]` &lt;dbl&gt;, …</code></pre>
</div>
</div>
<p>With this, we can visualize and summarize the posterior distributions for the different quantities of interest like we did in the <code>bayes_rapm_stand.qmd</code> demo. Just for demonstration, I’m visualizing the <code>is_home</code> posterior samples below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>posterior_sample <span class="sc">|&gt;</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> is_home)) <span class="sc">+</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>() <span class="sc">+</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>You’ll notice that the random intercepts and variance terms for the team groups have annoying text in them, which will require careful cleaning using functions like <code>str_remove</code>. For instance, the histogram below displays the distributions of the variance terms for the offense and defense groups:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>posterior_sample <span class="sc">|&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="fu">contains</span>(<span class="st">"Sigma"</span>)) <span class="sc">|&gt;</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">pivot_longer</span>(<span class="at">cols =</span> <span class="fu">everything</span>(),</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>               <span class="at">names_to =</span> <span class="st">"group"</span>, <span class="at">values_to =</span> <span class="st">"posterior_sample"</span>) <span class="sc">|&gt;</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> posterior_sample)) <span class="sc">+</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>() <span class="sc">+</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>group, <span class="at">ncol =</span> <span class="dv">1</span>) <span class="sc">+</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>You could proceed to visualize and summarize the team posterior distributions similar to the <code>bayes_rapm_stan.qmd</code> demo.</p>
</section>
<section id="generating-posterior-predictions" class="level2">
<h2 class="anchored" data-anchor-id="generating-posterior-predictions">Generating posterior predictions</h2>
<p>Previously, when we used frequentist regression models (with or without multilevel components) to generate predictions - we were estimating the conditional expectation of the response given the predictor variables. We only had a single point estimate for the prediction, but could construct a confidence interval to quantify uncertainty about the conditional mean estimate or a prediction interval for an individual observation. For Bayesian regression models, we use the posterior samples for our parameters to generate predictions which directly provides us with full distributions for every prediction.</p>
<p>Let’s consider making a prediction for the following hypothetical example for the number of goals scored by Chelsea at home against Liverpool:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool <span class="ot">&lt;-</span> <span class="fu">tibble</span>(<span class="at">off_team =</span> <span class="st">"Chelsea"</span>, <span class="at">def_team =</span> <span class="st">"Liverpool"</span>,</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>                            <span class="at">is_home =</span> <span class="dv">1</span>)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 3
  off_team def_team  is_home
  &lt;chr&gt;    &lt;chr&gt;       &lt;dbl&gt;
1 Chelsea  Liverpool       1</code></pre>
</div>
</div>
<p>In order to predictions for this game, we will need to use the posterior distribution samples for these parameters of interest. Remember we have 4,000 samples quantifying the uncertainty about these parameters:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="ot">&lt;-</span> posterior_sample <span class="sc">|&gt;</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>  dplyr<span class="sc">::</span><span class="fu">select</span>(<span class="st">`</span><span class="at">(Intercept)</span><span class="st">`</span>, <span class="st">`</span><span class="at">is_home</span><span class="st">`</span>, <span class="st">`</span><span class="at">b[(Intercept) off_team:Chelsea]</span><span class="st">`</span>,</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>                <span class="st">`</span><span class="at">b[(Intercept) def_team:Liverpool]</span><span class="st">`</span>) <span class="sc">|&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Clean up the column names for ease:</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>  janitor<span class="sc">::</span><span class="fu">clean_names</span>()</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 4
   intercept is_home b_intercept_off_team_chelsea b_intercept_def_team_liverpool
       &lt;dbl&gt;   &lt;dbl&gt;                        &lt;dbl&gt;                          &lt;dbl&gt;
 1     0.335   0.180                       0.306                          -0.314
 2     0.288   0.287                       0.140                          -0.189
 3     0.226   0.271                       0.0235                         -0.140
 4     0.454   0.123                       0.414                          -0.467
 5     0.394   0.164                       0.327                          -0.490
 6     0.469   0.157                       0.123                          -0.527
 7     0.474   0.204                       0.118                          -0.248
 8     0.449   0.225                       0.224                          -0.323
 9     0.468   0.209                       0.143                          -0.211
10     0.531   0.189                       0.0737                         -0.415
# ℹ 3,990 more rows</code></pre>
</div>
</div>
<p>Remember, we can effectively do whatever we want with our parameters’ posterior distribution samples. This includes computing estimates for the usual type of predictions or estimates for the conditional expectation of the response given inputs. For the Poisson example, the linear model predictions are on the log-link scale, i.e., <span class="math inline">\(\log \lambda | X = X\beta\)</span>, so we could simply across the columns to generate a full distribution for the estimate of this conditional expectation and then exponentiate (or more generally transform using the inverse-link function) to get on the response scale. Then just like before with our parameters of interest, we can visualize and summarize this posterior distribution for the conditional expectation of goals scored by Chelsea at home against (as demonstrated in the code chunk below).</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="ot">&lt;-</span> chelsea_liverpool_samples <span class="sc">|&gt;</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">log_pred =</span> intercept <span class="sc">+</span> is_home <span class="sc">+</span> b_intercept_off_team_chelsea <span class="sc">+</span> </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>           b_intercept_def_team_liverpool,</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>         <span class="at">response_pred =</span> <span class="fu">exp</span>(log_pred))</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 6
   intercept is_home b_intercept_off_team_chel…¹ b_intercept_def_team…² log_pred
       &lt;dbl&gt;   &lt;dbl&gt;                       &lt;dbl&gt;                  &lt;dbl&gt;    &lt;dbl&gt;
 1     0.335   0.180                      0.306                  -0.314    0.507
 2     0.288   0.287                      0.140                  -0.189    0.527
 3     0.226   0.271                      0.0235                 -0.140    0.381
 4     0.454   0.123                      0.414                  -0.467    0.524
 5     0.394   0.164                      0.327                  -0.490    0.394
 6     0.469   0.157                      0.123                  -0.527    0.222
 7     0.474   0.204                      0.118                  -0.248    0.547
 8     0.449   0.225                      0.224                  -0.323    0.575
 9     0.468   0.209                      0.143                  -0.211    0.609
10     0.531   0.189                      0.0737                 -0.415    0.378
# ℹ 3,990 more rows
# ℹ abbreviated names: ¹​b_intercept_off_team_chelsea,
#   ²​b_intercept_def_team_liverpool
# ℹ 1 more variable: response_pred &lt;dbl&gt;</code></pre>
</div>
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the distribution for Chelsea's predicted goals at home again Liverpool</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="sc">|&gt;</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> response_pred)) <span class="sc">+</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>() <span class="sc">+</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute summaries of the posterior distribution:</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="sc">|&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarize</span>(<span class="at">posterior_mean =</span> <span class="fu">mean</span>(response_pred), </span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>            <span class="at">posterior_median =</span> <span class="fu">median</span>(response_pred),</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>            <span class="co"># 80% credible interval:</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>            <span class="at">lower_80 =</span> <span class="fu">quantile</span>(response_pred, <span class="fl">0.1</span>),</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>            <span class="at">upper_80 =</span> <span class="fu">quantile</span>(response_pred, <span class="fl">0.9</span>))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 1 × 4
  posterior_mean posterior_median lower_80 upper_80
           &lt;dbl&gt;            &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
1           1.60             1.58     1.27     1.96</code></pre>
</div>
</div>
<p>While the above is analogous to generating predictions with regression models in the usual sense, the quantified uncertainty only captures the <strong>epistemic uncertainty</strong> - the uncertainty over the model parameters that we hope to reduce to informative features and data. But, if we want to account for the <strong>aleatoric uncertainty</strong> - the uncertainty due to the randomness intrinsic to the problem that is not explained by observed variables - then the posterior distribution for the conditional expectation is insufficient! Instead, we also need to draw values from the assumed model generating the data. In this case, we are assuming the goals scored follows a Poisson distribution, i.e., goals scored <span class="math inline">\(\sim \text{Poisson}(\lambda)\)</span>. Since we have 4000 values for the estimated scoring rate <span class="math inline">\(\lambda\)</span>, we can then generate 4000 values for the predicted number of goals scored with effectively 4000 different distributions! If that sounds a bit wild to you, that’s because it is actually an appropriate way to propagate uncertainty through your regression model: we’re generating predictions that accounts for parameter-level uncertainty AND outcome-level uncertainty.</p>
<p>The code chunk below shows how to generate the Poisson predictions using the conditional expectation samples from before (notice the use of setting the seed due to the randomness here!), along with a histogram displaying the resulting distribution:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">326</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="ot">&lt;-</span> chelsea_liverpool_samples <span class="sc">|&gt;</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Vectorized sampling of the goals scored by Chelsea:</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">goals_scored =</span> <span class="fu">rpois</span>(<span class="fu">n</span>(), response_pred))</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>chelsea_liverpool_samples <span class="sc">|&gt;</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> goals_scored)) <span class="sc">+</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_histogram</span>() <span class="sc">+</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_bw</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The above samples and resulting histogram are called the <strong>posterior predictive distribution</strong>, as it captures the generation of observations from the distribution of the outcome implied by the posterior distribution of the parameters of interest.</p>
<p>BUT - we just talked walked through this process for only a single observation! All of those steps were used to generate the posterior distribution predictions for Chelsea’s goals scored against Liverpool at home. <strong>We need to do this process for every single observation we want to generate predictions for!</strong></p>
<p>Here’s the good news, <code>rstanarm</code> has easy-to-use functions to repeat this process for across all observations we want to generate predictions for with uncertainty quantification. This is separated by the two different versions:</p>
<ol type="1">
<li><strong>Posterior distribution for conditional expectation</strong></li>
</ol>
<ul>
<li><code>posterior_linpred()</code> - generates posterior draws of the linear predictor on the link scale (i.e., the posterior distribution for the model parameters aggregated together). For the Poisson example, this is on the log scale like the <code>log_pred</code> values from above. The code chunk below shows how these are equivalent:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">posterior_linpred</span>(team_goals_model, <span class="at">newdata =</span> chelsea_liverpool) <span class="sc">|&gt;</span> <span class="fu">as_tibble</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 1
     `1`
   &lt;dbl&gt;
 1 0.507
 2 0.527
 3 0.381
 4 0.524
 5 0.394
 6 0.222
 7 0.547
 8 0.575
 9 0.609
10 0.378
# ℹ 3,990 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Just display the first so many of the manually computed values:</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(chelsea_liverpool_samples<span class="sc">$</span>log_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0.5065675 0.5268763 0.3810484 0.5239878 0.3944887 0.2215395</code></pre>
</div>
</div>
<ul>
<li><code>posterior_epred()</code> - same as <code>posterior_linpred()</code>, EXCEPT the response values are transformed by inverse-link function (equivalent to using <code>transform = TRUE</code> in <code>posterior_linpred()</code>). For the Poisson example, this is the <code>response_pred</code> column that results from taking the exponential of linear model predictions <code>log_pred</code>. If your model is Gaussian, then <code>posterior_linpred()</code> and <code>posterior_epred()</code> are equivalent. The code chunk below shows how this generates the same output from the manual version above:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="fu">posterior_epred</span>(team_goals_model, <span class="at">newdata =</span> chelsea_liverpool) <span class="sc">|&gt;</span> <span class="fu">as_tibble</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 1
     `1`
   &lt;dbl&gt;
 1  1.66
 2  1.69
 3  1.46
 4  1.69
 5  1.48
 6  1.25
 7  1.73
 8  1.78
 9  1.84
10  1.46
# ℹ 3,990 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(chelsea_liverpool_samples<span class="sc">$</span>response_pred)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.659585 1.693634 1.463818 1.688749 1.483625 1.247996</code></pre>
</div>
</div>
<ul>
<li>By default, you should use <code>posterior_epred()</code> instead of <code>posterior_linpred()</code> because of the link transformation to the response scale. The following code chunk shows what the output looks like for generating the posterior distributions of the conditional expectations for each of the observations in the data where each row is a posterior sample while <strong>each column is an observation from the dataset that we’re interested in generating predictions for</strong>:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="fu">posterior_epred</span>(team_goals_model, <span class="at">newdata =</span> eng_match_goals_scored) <span class="sc">|&gt;</span> </span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 760
     `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`  `11`  `12`  `13`
   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
 1 0.792  2.25  1.13 1.29   2.19  1.92  2.28  1.74  1.66  1.58  1.54  2.28  1.69
 2 1.14   2.83  1.11 1.06   2.25  1.40  2.14  2.27  1.69  1.86  1.53  2.53  1.60
 3 0.693  2.91  1.43 1.24   1.97  1.47  1.44  1.51  1.46  1.90  1.10  1.77  1.74
 4 1.07   2.17  1.13 0.868  2.02  2.10  3.18  1.59  1.69  1.55  2.31  2.64  2.04
 5 1.27   2.24  1.31 0.827  2.25  1.84  2.56  1.46  1.48  1.57  1.87  2.23  2.08
 6 0.623  2.02  1.75 1.09   1.48  1.76  2.17  1.58  1.25  1.91  2.37  1.78  1.99
 7 0.831  2.61  1.21 1.42   2.00  1.70  2.79  1.43  1.73  1.96  2.29  2.05  1.71
 8 0.907  2.87  1.65 1.22   2.30  1.80  1.84  1.56  1.78  1.92  1.95  2.72  1.45
 9 1.16   2.22  1.75 1.27   2.13  1.40  1.72  1.61  1.84  1.78  1.47  1.86  1.84
10 0.859  2.12  1.52 1.16   2.57  1.36  1.79  1.62  1.46  1.94  1.84  1.59  2.59
# ℹ 3,990 more rows
# ℹ 747 more variables: `14` &lt;dbl&gt;, `15` &lt;dbl&gt;, `16` &lt;dbl&gt;, `17` &lt;dbl&gt;,
#   `18` &lt;dbl&gt;, `19` &lt;dbl&gt;, `20` &lt;dbl&gt;, `21` &lt;dbl&gt;, `22` &lt;dbl&gt;, `23` &lt;dbl&gt;,
#   `24` &lt;dbl&gt;, `25` &lt;dbl&gt;, `26` &lt;dbl&gt;, `27` &lt;dbl&gt;, `28` &lt;dbl&gt;, `29` &lt;dbl&gt;,
#   `30` &lt;dbl&gt;, `31` &lt;dbl&gt;, `32` &lt;dbl&gt;, `33` &lt;dbl&gt;, `34` &lt;dbl&gt;, `35` &lt;dbl&gt;,
#   `36` &lt;dbl&gt;, `37` &lt;dbl&gt;, `38` &lt;dbl&gt;, `39` &lt;dbl&gt;, `40` &lt;dbl&gt;, `41` &lt;dbl&gt;,
#   `42` &lt;dbl&gt;, `43` &lt;dbl&gt;, `44` &lt;dbl&gt;, `45` &lt;dbl&gt;, `46` &lt;dbl&gt;, `47` &lt;dbl&gt;, …</code></pre>
</div>
</div>
<ol start="2" type="1">
<li><strong>Posterior predictive distribution</strong></li>
</ol>
<ul>
<li><code>posterior_predict()</code> - generates posterior draws from the distribution of the outcome implied by the posterior distribution for the parameter. This is equivalent to how we generated the <code>goals_scored</code> values from above by sampling from the Poisson distribution for each of the 4000 samples. You can see this match in the code chunk below:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="fu">posterior_predict</span>(team_goals_model, <span class="at">newdata =</span> chelsea_liverpool,</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>                  <span class="at">seed =</span> <span class="dv">326</span>) <span class="sc">|&gt;</span> <span class="fu">as_tibble</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 1
     `1`
   &lt;int&gt;
 1     2
 2     2
 3     1
 4     2
 5     4
 6     0
 7     2
 8     0
 9     3
10     1
# ℹ 3,990 more rows</code></pre>
</div>
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(chelsea_liverpool_samples<span class="sc">$</span>goals_scored)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 2 2 1 2 4 0</code></pre>
</div>
</div>
<ul>
<li>And just like with <code>posterior_epred()</code>, if we give a dataset with more than one observation then the posterior predictive distributions will have separate columns for each observation:</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="fu">posterior_predict</span>(team_goals_model, <span class="at">newdata =</span> eng_match_goals_scored) <span class="sc">|&gt;</span> </span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 760
     `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`  `11`  `12`  `13`
   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
 1     0     4     2     0     2     2     2     3     3     0     4     2     2
 2     2     2     2     0     3     3     2     2     4     0     1     1     2
 3     0     5     0     4     2     0     2     0     1     6     2     0     2
 4     0     1     0     0     2     4     1     3     2     1     1     1     2
 5     3     5     1     1     2     3     4     0     0     3     1     2     5
 6     1     0     2     1     0     2     3     1     1     0     2     3     3
 7     3     4     3     2     1     2     0     1     1     1     2     4     2
 8     1     4     2     0     4     2     1     4     0     0     3     5     0
 9     0     4     1     1     6     3     2     3     2     4     0     2     2
10     2     1     3     2     0     1     3     3     1     1     1     1     2
# ℹ 3,990 more rows
# ℹ 747 more variables: `14` &lt;int&gt;, `15` &lt;int&gt;, `16` &lt;int&gt;, `17` &lt;int&gt;,
#   `18` &lt;int&gt;, `19` &lt;int&gt;, `20` &lt;int&gt;, `21` &lt;int&gt;, `22` &lt;int&gt;, `23` &lt;int&gt;,
#   `24` &lt;int&gt;, `25` &lt;int&gt;, `26` &lt;int&gt;, `27` &lt;int&gt;, `28` &lt;int&gt;, `29` &lt;int&gt;,
#   `30` &lt;int&gt;, `31` &lt;int&gt;, `32` &lt;int&gt;, `33` &lt;int&gt;, `34` &lt;int&gt;, `35` &lt;int&gt;,
#   `36` &lt;int&gt;, `37` &lt;int&gt;, `38` &lt;int&gt;, `39` &lt;int&gt;, `40` &lt;int&gt;, `41` &lt;int&gt;,
#   `42` &lt;int&gt;, `43` &lt;int&gt;, `44` &lt;int&gt;, `45` &lt;int&gt;, `46` &lt;int&gt;, `47` &lt;int&gt;, …</code></pre>
</div>
</div>
</section>
<section id="posterior-predictive-check" class="level2">
<h2 class="anchored" data-anchor-id="posterior-predictive-check">Posterior predictive check</h2>
<p>The posterior predictive distribution is also useful to consider for model diagnostics. If you randomly grabbed a row from the above table generated in the previous code chunk, you could observe what the resulting distribution of values looks like via a histogram or density curve. You want that distribution across all observations to be similar to the actual observed response variable distribution. Of course, we have 4000 rows in that table and thus have 4000 distributions for which we can compare against the observed outcome distribution. The inspection of the posterior predictive distributions is called <a href="https://mc-stan.org/rstanarm/reference/pp_check.stanreg.html"><strong>posterior predictive check</strong></a>. This is commonly used diagnostic to see how the distribution of the posterior draws for the model’s training data compares to the actual observed distribution of training data response values. This can be easily created with the <code>pp_check</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pp_check</span>(team_goals_model) <span class="sc">+</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_light</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-18-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="prior-predictive-check" class="level2">
<h2 class="anchored" data-anchor-id="prior-predictive-check">Prior predictive check</h2>
<p>We have not mentioned at all yet what the prior distributions were for the considered model. We can check to see what Stan used with the <code>prior_summary()</code> function:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="fu">prior_summary</span>(<span class="at">object =</span> team_goals_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Priors for model 'team_goals_model' 
------
Intercept (after predictors centered)
 ~ normal(location = 0, scale = 2.5)

Coefficients
  Specified prior:
    ~ normal(location = 0, scale = 2.5)
  Adjusted prior:
    ~ normal(location = 0, scale = 5)

Covariance
 ~ decov(reg. = 1, conc. = 1, shape = 1, scale = 1)
------
See help('prior_summary.stanreg') for more details</code></pre>
</div>
</div>
<p>You can read more about the default priors in the <a href="https://mc-stan.org/rstanarm/articles/priors.html"><em>Prior Distributions for <code>rstanarm</code> Models</em></a> vignette.</p>
<p>While we just discussed the use of the posterior predictive check as a means for assessing the posterior distribution model fit, <strong>we can also do the same type of procedure WITHOUT observing data!</strong> This is known as a <strong>prior predictive check</strong> and it just involves the exact same steps as how we generated predictions with the posterior - except we can generate predictions only using the prior distributions for the parameters of interest. This is a great way to evaluate if your prior is appropriate.</p>
<p>You can implement a prior predictive check by first “re-fitting” the same model, except you’ll tell Stan to ignore the data and only use the prior via <code>prior_PD = TRUE</code>. You still have to provide the data so Stan knows how to set-up the variables in the resulting output.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>prior_team_goals_model <span class="ot">&lt;-</span> <span class="fu">stan_glmer</span>(goals <span class="sc">~</span> is_home <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> off_team) <span class="sc">+</span> (<span class="dv">1</span> <span class="sc">|</span> def_team),</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">family =</span> poisson,</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">data =</span> eng_match_goals_scored, <span class="at">seed =</span> <span class="dv">2013</span>,</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>                                     <span class="at">prior_PD =</span> <span class="cn">TRUE</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
SAMPLING FOR MODEL 'count' NOW (CHAIN 1).
Chain 1: 
Chain 1: Gradient evaluation took 1.5e-05 seconds
Chain 1: 1000 transitions using 10 leapfrog steps per transition would take 0.15 seconds.
Chain 1: Adjust your expectations accordingly!
Chain 1: 
Chain 1: 
Chain 1: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 1: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 1: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 1: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 1: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 1: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 1: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 1: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 1: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 1: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 1: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 1: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 1: 
Chain 1:  Elapsed Time: 0.065 seconds (Warm-up)
Chain 1:                0.063 seconds (Sampling)
Chain 1:                0.128 seconds (Total)
Chain 1: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 2).
Chain 2: 
Chain 2: Gradient evaluation took 6e-06 seconds
Chain 2: 1000 transitions using 10 leapfrog steps per transition would take 0.06 seconds.
Chain 2: Adjust your expectations accordingly!
Chain 2: 
Chain 2: 
Chain 2: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 2: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 2: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 2: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 2: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 2: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 2: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 2: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 2: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 2: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 2: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 2: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 2: 
Chain 2:  Elapsed Time: 0.065 seconds (Warm-up)
Chain 2:                0.061 seconds (Sampling)
Chain 2:                0.126 seconds (Total)
Chain 2: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 3).
Chain 3: 
Chain 3: Gradient evaluation took 1.2e-05 seconds
Chain 3: 1000 transitions using 10 leapfrog steps per transition would take 0.12 seconds.
Chain 3: Adjust your expectations accordingly!
Chain 3: 
Chain 3: 
Chain 3: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 3: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 3: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 3: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 3: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 3: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 3: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 3: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 3: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 3: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 3: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 3: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 3: 
Chain 3:  Elapsed Time: 0.062 seconds (Warm-up)
Chain 3:                0.064 seconds (Sampling)
Chain 3:                0.126 seconds (Total)
Chain 3: 

SAMPLING FOR MODEL 'count' NOW (CHAIN 4).
Chain 4: 
Chain 4: Gradient evaluation took 5e-06 seconds
Chain 4: 1000 transitions using 10 leapfrog steps per transition would take 0.05 seconds.
Chain 4: Adjust your expectations accordingly!
Chain 4: 
Chain 4: 
Chain 4: Iteration:    1 / 2000 [  0%]  (Warmup)
Chain 4: Iteration:  200 / 2000 [ 10%]  (Warmup)
Chain 4: Iteration:  400 / 2000 [ 20%]  (Warmup)
Chain 4: Iteration:  600 / 2000 [ 30%]  (Warmup)
Chain 4: Iteration:  800 / 2000 [ 40%]  (Warmup)
Chain 4: Iteration: 1000 / 2000 [ 50%]  (Warmup)
Chain 4: Iteration: 1001 / 2000 [ 50%]  (Sampling)
Chain 4: Iteration: 1200 / 2000 [ 60%]  (Sampling)
Chain 4: Iteration: 1400 / 2000 [ 70%]  (Sampling)
Chain 4: Iteration: 1600 / 2000 [ 80%]  (Sampling)
Chain 4: Iteration: 1800 / 2000 [ 90%]  (Sampling)
Chain 4: Iteration: 2000 / 2000 [100%]  (Sampling)
Chain 4: 
Chain 4:  Elapsed Time: 0.063 seconds (Warm-up)
Chain 4:                0.062 seconds (Sampling)
Chain 4:                0.125 seconds (Total)
Chain 4: </code></pre>
</div>
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>prior_sample <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(prior_team_goals_model) <span class="sc">|&gt;</span> <span class="fu">as_tibble</span>()</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>prior_sample</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code># A tibble: 4,000 × 44
   `(Intercept)` is_home b[(Intercept) off_team:Arsenal…¹ b[(Intercept) off_te…²
           &lt;dbl&gt;   &lt;dbl&gt;                            &lt;dbl&gt;                  &lt;dbl&gt;
 1         0.972  -1.46                           -0.0434                0.00993
 2         0.468   4.27                           -0.0494               -0.0662 
 3         1.88   -7.61                            0.349                 0.227  
 4         2.93   -0.610                          -0.179                -0.192  
 5         1.15    0.480                           0.697                 0.632  
 6         0.364   2.09                            0.765                 0.112  
 7        -3.51   -2.00                           -0.403                 0.288  
 8         3.69    0.336                           0.802                -0.381  
 9         0.644  -1.92                            0.0860               -0.876  
10         4.66   -4.31                            0.345                 1.86   
# ℹ 3,990 more rows
# ℹ abbreviated names: ¹​`b[(Intercept) off_team:Arsenal]`,
#   ²​`b[(Intercept) off_team:Aston_Villa]`
# ℹ 40 more variables: `b[(Intercept) off_team:Bournemouth]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Brentford]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Brighton]` &lt;dbl&gt;,
#   `b[(Intercept) off_team:Burnley]` &lt;dbl&gt;, …</code></pre>
</div>
</div>
<p>Notice how this barely took any time, because the data was completely ignored - this is just shortcut for drawing from the prior distribution! We can then re-use the same <code>pp_check()</code> function to visualize the prior predictive distributions across these 4000 prior samples:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="fu">pp_check</span>(prior_team_goals_model) <span class="sc">+</span> </span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">scale_x_continuous</span>(<span class="at">limits =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">10</span>)) <span class="sc">+</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_light</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Removed 11641 rows containing non-finite outside the scale range
(`stat_density()`).</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="16-team-ratings_files/figure-html/unnamed-chunk-21-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>I manually truncated the x-axis here, <strong>but what do you think about the values generated from this prior distribution?</strong></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/ryurko\.github\.io\/cmu-sportsanalytics-spring25\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>